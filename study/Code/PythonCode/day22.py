#!/usr/bin/env python
# -*- coding: utf-8 -*-
#1,打开文件，由应用程序向操作系统发起系统调用open（），操作系统打开该文件，对应一块硬盘空间，并返回一个文件对象赋值给一个变量F
f=open('day1.py','r',encoding='utf-8') #默认打开模式就为r
print(f)
#2, 调用文件对象下的读/写方法，会被操作系统转换为读/写硬盘的操作
date=f.read()
print(date)
#向操作系统发起关闭文件的请求，回收系统资源
f.close()
#2.2 资源回收与with上下文管理
#打开一个文件包含两部分资源：应用程序的变量F和操作系统打开的文件。在操作完毕一个文件时，必须把与该文件的这两部分资源全部回收，回收方法为：
f.close() #回收操作系统打开的文件资源
del f #回收应用程序级的变量

#其中del f 一定要发生在f.close之后，否者就会导致操作系统打开的文件无法关闭，白白占用资源，
#而python 自动的垃圾回收机制决定了我们无需考虑del f，这就要求我们，在操作完毕文件后，一定要记住f.close（）。虽然我们如此强调，
#但是大多数读者还是会不由自主的忘记f.close().考虑到这一点，python提供了with 关键字来帮忙我们管理上下文
#1，在执行万子代码块后，with 会自动执行f.close()
with open ('day2.py','w') as f:
    pass
#2,可用with同时打开多个文件，用逗号分隔即可
with open('day2.py','r') as read_f, open ('day5.py','w') as write_f:
    data=read_f.read()
    write_f.write(data)
#2.3 指定操作文本文件的字符编码
#f=open（）是由操作系统打开文件，如果打开的是文本文件，会涉及到字符编码的问题，如果没有为open指定编码，那么打开文本文件的默认
#编码去打开文件，在window下是gbk，在Linux下是utf-8，这就用到了上节课讲的字符编码的知识，若要保证不乱码，文件以什么方式存的，就要以什么方式打开
f=open('day7.py','r',encoding='utf-8')
#文件的操作模式
#3.1 控制文件读写操作的模式
'''
r(默认的)：只读
w:只写
a:只追加写
'''

